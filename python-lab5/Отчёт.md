# **Отчёт по лабораторной работе**  
**Тема:** Применение паттернов проектирования в системе учета сотрудников

## Сведения о студенте
**Дата:** 2025-11-24
**Семестр:** 2 курс 1 семестр
**Группа:** ПИН-Б-О-24-2
**Дисциплина:** Технологии программирования
**Студент:** Пахомов Давид Вадимович

---

## Оглавление

1. [Введение](#введение)
2. [Структура проекта](#структура-проекта)
3. [Часть 1: Порождающие паттерны](#часть-1-порождающие-паттерны)
4. [Часть 2: Структурные паттерны](#часть-2-структурные-паттерны)
5. [Часть 3: Поведенческие паттерны](#часть-3-поведенческие-паттерны)
6. [Часть 4: Комбинированные паттерны](#часть-4-комбинированные-паттерны)
7. [Сравнение до и после рефакторинга](#сравнение-до-и-после-рефакторинга)
8. [Заключение](#заключение)
9. [Приложения](#приложения)

---

## Введение

### Цель работы
Освоить практическое применение паттернов проектирования для рефакторинга и улучшения кодовой базы системы учета сотрудников. Получить навыки применения различных паттернов для решения типичных задач проектирования ПО.

### Используемые технологии
- **Язык программирования:** Python 3.8+
- **База данных:** SQLite (опционально)
- **Дополнительные библиотеки:** `abc`, `json`, `sqlite3`
- **Инструменты:** Любая IDE, Git

### Теоретическая часть
Паттерны проектирования — это типичные способы решения часто встречающихся проблем в проектировании ПО. В данной работе рассматриваются:

1. **Порождающие паттерны:** Singleton, Factory Method, Abstract Factory, Builder
2. **Структурные паттерны:** Adapter, Decorator, Facade
3. **Поведенческие паттерны:** Observer, Strategy, Command
4. **Комбинированные паттерны:** Repository, Unit of Work, Specification

---

## Структура проекта

```
python-lab5/
├── src/                          # Исходный код системы
│   ├── core/                     # Основные классы системы
│   │   ├── abstract_employee.py  # Абстрактный класс AbstractEmployee
│   │   ├── employee.py           # Базовый класс Employee
│   │   ├── department.py         # Класс Department
│   │   ├── company.py            # Класс Company
│   │   └── project.py            # Класс Project
│   ├── employees/                # Классы сотрудников
│   │   ├── manager.py            # Класс Manager
│   │   ├── developer.py          # Класс Developer
│   │   └── salesperson.py       # Класс Salesperson
│   ├── factories/                # Фабрики
│   │   ├── employee_factory.py   # Factory Method
│   │   └── company_factory.py    # Abstract Factory
│   ├── patterns/                 # Реализации паттернов
│   │   ├── singleton.py         # Singleton
│   │   ├── builder.py           # Builder
│   │   ├── adapter.py            # Adapter
│   │   ├── decorator.py          # Decorator
│   │   ├── facade.py             # Facade
│   │   ├── observer.py           # Observer
│   │   ├── strategy.py           # Strategy
│   │   ├── command.py            # Command
│   │   ├── repository.py         # Repository
│   │   ├── unit_of_work.py       # Unit of Work
│   │   └── specification.py      # Specification
│   ├── database/                 # Работа с базой данных
│   │   └── connection.py         # Singleton для подключения
│   └── utils/                    # Вспомогательные модули
│       └── exceptions.py         # Кастомные исключения
├── examples/                     # Примеры использования
│   └── demo_patterns.py         # Демонстрация всех паттернов
├── README.md                     # Описание проекта
└── Отчёт.md                      # Отчёт по лабораторной работе
```

---

## Часть 1: Порождающие паттерны

### 1.1. Singleton (Одиночка)

**Задача:** Создать класс `DatabaseConnection` для управления подключением к БД SQLite.

**Требования:** Гарантировать единственное подключение к БД в рамках приложения.

**Реализация:**

```python
class DatabaseConnection:
    _instance = None
    _connection = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(DatabaseConnection, cls).__new__(cls)
        return cls._instance
    
    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance
```

**Демонстрация:**

```python
db1 = DatabaseConnection.get_instance()
db2 = DatabaseConnection.get_instance()
print(f"Singleton test: {db1 is db2}")  # True
```

**Преимущества:**
- Гарантирует единственный экземпляр подключения
- Экономит ресурсы
- Упрощает управление состоянием

**Недостатки:**
- Усложняет тестирование
- Может скрывать зависимости
- Потенциальные проблемы с многопоточностью

---

### 1.2. Factory Method (Фабричный метод)

**Задача:** Рефакторинг существующей `EmployeeFactory` из ЛР №2.

**Требования:** Создать абстрактный класс `EmployeeFactory` с методом `create_employee()`. Реализовать конкретные фабрики для каждого типа сотрудников.

**Реализация:**

```python
class EmployeeFactory(ABC):
    @abstractmethod
    def create_employee(self, **kwargs) -> AbstractEmployee:
        pass

class ManagerFactory(EmployeeFactory):
    def create_employee(self, **kwargs) -> Manager:
        return Manager(
            id=kwargs.get("id"),
            name=kwargs.get("name"),
            department=kwargs.get("department"),
            base_salary=kwargs.get("base_salary"),
            bonus=kwargs.get("bonus", 0)
        )
```

**Демонстрация:**

```python
manager_factory = ManagerFactory()
manager = manager_factory.create_employee(
    id=1, name="Алиса", department="MANAGEMENT", 
    base_salary=70000, bonus=20000
)
```

**Преимущества:**
- Инкапсулирует создание объектов
- Упрощает добавление новых типов
- Разделяет ответственность

**Недостатки:**
- Увеличивает количество классов
- Может быть избыточным для простых случаев

---

### 1.3. Abstract Factory (Абстрактная фабрика)

**Задача:** Создать фабрики для разных типов компаний (`TechCompanyFactory`, `SalesCompanyFactory`).

**Требования:** Каждая фабрика создает согласованный набор объектов (специфических сотрудников, отделов, проектов).

**Реализация:**

```python
class CompanyFactory(ABC):
    @abstractmethod
    def create_company(self, name: str) -> Company:
        pass
    
    @abstractmethod
    def create_department(self, name: str) -> Department:
        pass
    
    @abstractmethod
    def create_project(self, project_id: int, name: str, 
                      description: str, deadline: str) -> Project:
        pass

class TechCompanyFactory(CompanyFactory):
    def create_company(self, name: str) -> Company:
        company = Company(name)
        dev_dept = self.create_department("Development")
        company.add_department(dev_dept)
        # ... создание проектов
        return company
```

**Демонстрация:**

```python
tech_factory = TechCompanyFactory()
tech_company = tech_factory.create_company("TechCorp")
# Создана компания с техническими отделами и проектами
```

**Преимущества:**
- Гарантирует согласованность объектов
- Изолирует конкретные классы
- Упрощает замену семейств объектов

**Недостатки:**
- Сложность добавления новых типов объектов
- Большое количество классов

---

### 1.4. Builder (Строитель)

**Задача:** Создать `EmployeeBuilder` для пошагового создания сложных объектов сотрудников.

**Требования:** Реализовать fluent-интерфейс. Возможность создания сотрудников с различными опциональными параметрами.

**Реализация:**

```python
class EmployeeBuilder:
    def set_id(self, id: int) -> 'EmployeeBuilder':
        self._id = id
        return self
    
    def set_name(self, name: str) -> 'EmployeeBuilder':
        self._name = name
        return self
    
    def build(self) -> AbstractEmployee:
        # Валидация и создание объекта
        return Developer(...)
```

**Демонстрация:**

```python
developer = (EmployeeBuilder()
            .set_id(101)
            .set_name("John Doe")
            .set_department("DEV")
            .set_base_salary(5000)
            .set_skills(["Python", "Java"])
            .set_seniority("senior")
            .build())
```

**Преимущества:**
- Гибкое создание объектов
- Читаемый код
- Валидация на этапе построения

**Недостатки:**
- Дополнительный код для простых случаев
- Сложность для простых объектов

---

## Часть 2: Структурные паттерны

### 2.1. Adapter (Адаптер)

**Задача:** Создать адаптер для интеграции с внешней системой расчета зарплат.

**Требования:** Адаптировать интерфейс внешней библиотеки к интерфейсу нашей системы.

**Реализация:**

```python
class ExternalSalaryService:
    def compute_payment(self, employee_data: dict) -> float:
        # Внешний интерфейс
        pass

class SalaryCalculatorAdapter:
    def __init__(self, external_calculator):
        self._external_calculator = external_calculator
    
    def calculate_salary(self, employee: AbstractEmployee) -> float:
        employee_data = self._convert_to_external_format(employee)
        return self._external_calculator.compute_payment(employee_data)
```

**Демонстрация:**

```python
external_service = ExternalSalaryService()
adapter = SalaryCalculatorAdapter(external_service)
salary = adapter.calculate_salary(developer)
```

**Преимущества:**
- Интеграция несовместимых интерфейсов
- Переиспользование существующего кода
- Изоляция изменений

**Недостатки:**
- Дополнительный слой абстракции
- Потенциальная потеря производительности

---

### 2.2. Decorator (Декоратор)

**Задача:** Создать декораторы для добавления дополнительной функциональности сотрудникам.

**Требования:** Реализовать декораторы `BonusDecorator`, `TrainingDecorator` которые добавляют новые возможности существующим объектам.

**Реализация:**

```python
class EmployeeDecorator(AbstractEmployee):
    def __init__(self, employee: AbstractEmployee):
        self._employee = employee
    
    def calculate_salary(self) -> float:
        return self._employee.calculate_salary()

class BonusDecorator(EmployeeDecorator):
    def __init__(self, employee: AbstractEmployee, bonus_amount: float):
        super().__init__(employee)
        self._bonus_amount = bonus_amount
    
    def calculate_salary(self) -> float:
        return self._employee.calculate_salary() + self._bonus_amount
```

**Демонстрация:**

```python
developer = Developer(1, "Dev", "DEV", 50000, ["Python"], "middle")
decorated = BonusDecorator(developer, 5000)
decorated_with_training = TrainingDecorator(decorated, 2000)
```

**Преимущества:**
- Динамическое добавление функциональности
- Гибкая композиция
- Соблюдение принципа открытости/закрытости

**Недостатки:**
- Множество маленьких классов
- Сложность отладки цепочек декораторов

---

### 2.3. Facade (Фасад)

**Задача:** Создать упрощенный интерфейс для работы с сложной системой компании.

**Требования:** Класс `CompanyFacade` с методами для основных операций (найм, увольнение, расчет зарплат).

**Реализация:**

```python
class CompanyFacade:
    def __init__(self, company: Company):
        self._company = company
    
    def hire_employee(self, employee: AbstractEmployee, 
                     department_name: str) -> bool:
        department = self._find_department(department_name)
        department.add_employee(employee)
        return True
    
    def calculate_total_salaries(self) -> float:
        return self._company.calculate_total_monthly_cost()
```

**Демонстрация:**

```python
facade = CompanyFacade(company)
facade.hire_employee(developer, "Development")
total = facade.calculate_total_salaries()
```

**Преимущества:**
- Упрощение сложных систем
- Снижение связанности
- Удобный интерфейс для клиентов

**Недостатки:**
- Дополнительный слой абстракции
- Потенциальная потеря гибкости

---

## Часть 3: Поведенческие паттерны

### 3.1. Observer (Наблюдатель)

**Задача:** Реализовать систему уведомлений об изменениях в системе.

**Требования:** Создать `NotificationSystem` с методами подписки/отписки. Уведомлять о изменениях зарплат, статусов проектов.

**Реализация:**

```python
class Observer(ABC):
    @abstractmethod
    def update(self, event_type: str, data: dict) -> None:
        pass

class Subject(ABC):
    def __init__(self):
        self._observers: List[Observer] = []
    
    def attach(self, observer: Observer) -> None:
        self._observers.append(observer)
    
    def notify(self, event_type: str, data: dict) -> None:
        for observer in self._observers:
            observer.update(event_type, data)
```

**Демонстрация:**

```python
notification_system = NotificationSystem()
observable_employee = ObservableEmployee(developer)
observable_employee.attach(notification_system)
observable_employee.set_base_salary(60000)  # Отправляет уведомление
```

**Преимущества:**
- Слабая связанность
- Динамическая подписка
- Расширяемость

**Недостатки:**
- Потенциальные утечки памяти
- Непредсказуемый порядок уведомлений

---

### 3.2. Strategy (Стратегия)

**Задача:** Реализовать различные стратегии расчета бонусов.

**Требования:** Создать интерфейс `BonusStrategy` с реализациями `PerformanceBonus`, `SeniorityBonus`, `ProjectBonus`.

**Реализация:**

```python
class BonusStrategy(ABC):
    @abstractmethod
    def calculate_bonus(self, employee: AbstractEmployee) -> float:
        pass

class PerformanceBonusStrategy(BonusStrategy):
    def calculate_bonus(self, employee: AbstractEmployee) -> float:
        return employee.base_salary * 0.1

class BonusContext:
    def __init__(self, strategy: BonusStrategy):
        self._strategy = strategy
    
    def calculate_bonus(self, employee: AbstractEmployee) -> float:
        return self._strategy.calculate_bonus(employee)
```

**Демонстрация:**

```python
strategy = PerformanceBonusStrategy()
context = BonusContext(strategy)
bonus = context.calculate_bonus(developer)

# Смена стратегии
context.set_strategy(SeniorityBonusStrategy())
bonus = context.calculate_bonus(developer)
```

**Преимущества:**
- Взаимозаменяемые алгоритмы
- Избежание условных операторов
- Легкое добавление новых стратегий

**Недостатки:**
- Дополнительные классы
- Клиент должен знать о стратегиях

---

### 3.3. Command (Команда)

**Задача:** Реализовать систему команд для операций с сотрудниками.

**Требования:** Создать команды `HireEmployeeCommand`, `FireEmployeeCommand`, `UpdateSalaryCommand`. Реализовать механизм отмены операций.

**Реализация:**

```python
class Command(ABC):
    @abstractmethod
    def execute(self) -> bool:
        pass
    
    @abstractmethod
    def undo(self) -> bool:
        pass

class HireEmployeeCommand(Command):
    def execute(self) -> bool:
        department.add_employee(self._employee)
        return True
    
    def undo(self) -> bool:
        department.remove_employee(self._employee.id)
        return True
```

**Демонстрация:**

```python
invoker = CommandInvoker()
hire_command = HireEmployeeCommand(developer, company, "Development")
invoker.execute_command(hire_command)
invoker.undo()  # Отмена операции
```

**Преимущества:**
- Инкапсуляция запросов
- Поддержка отмены операций
- Логирование и очередь команд

**Недостатки:**
- Увеличение количества классов
- Сложность для простых операций

---

## Часть 4: Комбинированные паттерны

### 4.1. Repository Pattern

**Задача:** Создать репозитории для работы с данными.

**Требования:** `EmployeeRepository`, `DepartmentRepository` с методами CRUD.

**Реализация:**

```python
class IEmployeeRepository(ABC):
    @abstractmethod
    def add(self, employee: AbstractEmployee) -> None:
        pass
    
    @abstractmethod
    def get_by_id(self, employee_id: int) -> Optional[AbstractEmployee]:
        pass

class EmployeeRepository(IEmployeeRepository):
    def __init__(self):
        self._employees: dict[int, AbstractEmployee] = {}
    
    def add(self, employee: AbstractEmployee) -> None:
        self._employees[employee.id] = employee
```

**Демонстрация:**

```python
repo = EmployeeRepository()
repo.add(developer)
found = repo.get_by_id(1)
all_employees = repo.get_all()
```

**Преимущества:**
- Абстракция доступа к данным
- Упрощение тестирования
- Централизация логики доступа

**Недостатки:**
- Дополнительный слой абстракции
- Потенциальная избыточность для простых случаев

---

### 4.2. Unit of Work

**Задача:** Реализовать паттерн Unit of Work для управления транзакциями.

**Требования:** Гарантия согласованности данных при комплексных операциях.

**Реализация:**

```python
class UnitOfWork:
    def __init__(self):
        self._employee_repo = EmployeeRepository()
        self._new_employees: List = []
        self._modified_employees: List = []
    
    def register_new_employee(self, employee) -> None:
        self._new_employees.append(employee)
    
    def commit(self) -> None:
        for employee in self._new_employees:
            self._employee_repo.add(employee)
        # ... применение всех изменений атомарно
```

**Демонстрация:**

```python
uow = UnitOfWork()
uow.register_new_employee(developer)
uow.register_new_employee(manager)
uow.commit()  # Все изменения применяются атомарно
```

**Преимущества:**
- Атомарность операций
- Отслеживание изменений
- Упрощение управления транзакциями

**Недостатки:**
- Сложность реализации
- Потенциальные проблемы с памятью

---

### 4.3. Specification Pattern

**Задача:** Реализовать паттерн Спецификация для фильтрации сотрудников.

**Требования:** Создать спецификации `SalarySpecification`, `DepartmentSpecification`, `SkillSpecification`.

**Реализация:**

```python
class Specification(ABC):
    @abstractmethod
    def is_satisfied_by(self, employee: AbstractEmployee) -> bool:
        pass
    
    def __and__(self, other: 'Specification') -> 'AndSpecification':
        return AndSpecification(self, other)

class SalarySpecification(Specification):
    def __init__(self, min_salary: float):
        self._min_salary = min_salary
    
    def is_satisfied_by(self, employee: AbstractEmployee) -> bool:
        return employee.calculate_salary() >= self._min_salary
```

**Демонстрация:**

```python
high_salary_spec = SalarySpecification(min_salary=50000)
dev_spec = DepartmentSpecification("DEV")
combined_spec = high_salary_spec & dev_spec

spec_repo = SpecificationRepository(employees)
high_paid_devs = spec_repo.find_by_specification(combined_spec)
```

**Преимущества:**
- Гибкая фильтрация
- Композиция условий
- Читаемый код запросов

**Недостатки:**
- Дополнительные классы
- Потенциальная сложность для простых запросов

---

## Сравнение до и после рефакторинга

### До рефакторинга

```python
# Простое создание через конструктор
developer = Developer(1, "John", "DEV", 50000, ["Python"], "senior")

# Прямая работа с компанией
company = Company("TechCorp")
dept = Department("Development")
company.add_department(dept)
dept.add_employee(developer)
```

**Проблемы:**
- Жесткая связанность
- Сложность тестирования
- Нет поддержки отмены операций
- Нет системы уведомлений

### После рефакторинга

```python
# Использование Builder
developer = (EmployeeBuilder()
            .set_id(1)
            .set_name("John")
            .set_department("DEV")
            .set_base_salary(50000)
            .set_skills(["Python"])
            .set_seniority("senior")
            .build())

# Использование Facade
facade = CompanyFacade(company)
facade.hire_employee(developer, "Development")

# Использование Command с отменой
invoker = CommandInvoker()
command = HireEmployeeCommand(developer, company, "Development")
invoker.execute_command(command)
invoker.undo()  # Отмена операции
```

**Преимущества:**
- Гибкость и расширяемость
- Легкое тестирование
- Поддержка отмены операций
- Система уведомлений
- Чистая архитектура

---

## Заключение

### Достигнутые результаты

1. **Реализовано 13 паттернов проектирования:**
   - 4 порождающих паттерна
   - 3 структурных паттерна
   - 3 поведенческих паттерна
   - 3 комбинированных паттерна

2. **Улучшена архитектура системы:**
   - Снижена связанность компонентов
   - Повышена расширяемость
   - Упрощено тестирование

3. **Добавлена новая функциональность:**
   - Система уведомлений
   - Поддержка отмены операций
   - Гибкая фильтрация данных
   - Управление транзакциями

### Преимущества реализованного решения

- **Гибкость:** Легкое добавление новых типов сотрудников и функциональности
- **Масштабируемость:** Поддержка большого количества сотрудников и операций
- **Тестируемость:** Изолированные компоненты легко тестировать
- **Поддерживаемость:** Чистая архитектура и разделение ответственности
- **Расширяемость:** Новые паттерны легко интегрируются

### Возможности дальнейшего развития

- Интеграция с веб-интерфейсом
- Добавление модуля отчетности
- Поддержка распределенной архитектуры
- Интеграция с системами аутентификации
- Добавление кэширования через Proxy паттерн
- Реализация Chain of Responsibility для обработки запросов

### Выводы

В ходе выполнения лабораторной работы были успешно освоены и применены 13 паттернов проектирования. Реализованная система демонстрирует правильное применение порождающих, структурных и поведенческих паттернов. Код структурирован, документирован и готов к дальнейшему развитию. Применение паттернов значительно улучшило качество кода и упростило поддержку системы.

---

## Приложения

### Приложение A: Примеры использования

Все примеры использования находятся в файле `examples/demo_patterns.py`:
- Демонстрация Singleton
- Демонстрация Factory Method
- Демонстрация Abstract Factory
- Демонстрация Builder
- Демонстрация Adapter
- Демонстрация Decorator
- Демонстрация Facade
- Демонстрация Observer
- Демонстрация Strategy
- Демонстрация Command
- Демонстрация Repository
- Демонстрация Unit of Work
- Демонстрация Specification

### Приложение B: Структура паттернов

**Порождающие паттерны:**
- `DatabaseConnection` - Singleton
- `EmployeeFactory`, `ManagerFactory`, `DeveloperFactory`, `SalespersonFactory` - Factory Method
- `CompanyFactory`, `TechCompanyFactory`, `SalesCompanyFactory` - Abstract Factory
- `EmployeeBuilder` - Builder

**Структурные паттерны:**
- `SalaryCalculatorAdapter` - Adapter
- `EmployeeDecorator`, `BonusDecorator`, `TrainingDecorator`, `PerformanceDecorator` - Decorator
- `CompanyFacade` - Facade

**Поведенческие паттерны:**
- `Observer`, `Subject`, `NotificationSystem`, `ObservableEmployee` - Observer
- `BonusStrategy`, `PerformanceBonusStrategy`, `SeniorityBonusStrategy`, `ProjectBonusStrategy`, `BonusContext` - Strategy
- `Command`, `HireEmployeeCommand`, `FireEmployeeCommand`, `UpdateSalaryCommand`, `CommandInvoker` - Command

**Комбинированные паттерны:**
- `IEmployeeRepository`, `EmployeeRepository`, `IDepartmentRepository`, `DepartmentRepository`, `IProjectRepository`, `ProjectRepository` - Repository
- `UnitOfWork` - Unit of Work
- `Specification`, `SalarySpecification`, `DepartmentSpecification`, `SkillSpecification`, `SpecificationRepository` - Specification

### Приложение C: Ключевые методы

**DatabaseConnection:**
- `get_instance()` - Получить единственный экземпляр
- `get_connection()` - Получить подключение к БД
- `close_connection()` - Закрыть подключение

**EmployeeBuilder:**
- `set_id()`, `set_name()`, `set_department()`, `set_base_salary()` - Установка базовых параметров
- `set_type()`, `set_bonus()`, `set_skills()`, `set_seniority()` - Установка специфичных параметров
- `build()` - Построение объекта

**CompanyFacade:**
- `hire_employee()` - Нанять сотрудника
- `fire_employee()` - Уволить сотрудника
- `calculate_total_salaries()` - Рассчитать общие зарплаты
- `get_company_statistics()` - Получить статистику

**CommandInvoker:**
- `execute_command()` - Выполнить команду
- `undo()` - Отменить последнюю команду
- `redo()` - Повторить отмененную команду

**UnitOfWork:**
- `register_new_employee()`, `register_modified_employee()`, `register_deleted_employee()` - Регистрация изменений
- `commit()` - Применить все изменения атомарно
- `rollback()` - Откатить изменения

**Specification:**
- `is_satisfied_by()` - Проверить соответствие спецификации
- `__and__()`, `__or__()`, `__invert__()` - Комбинирование спецификаций

---

## Список использованных источников

1. Эрих Гамма, Ричард Хелм, Ральф Джонсон, Джон Влиссидес. "Приёмы объектно-ориентированного проектирования. Паттерны проектирования" (GoF)
2. Роберт Мартин. "Чистый код. Создание, анализ и рефакторинг"
3. Мартин Фаулер. "Рефакторинг. Улучшение существующего кода"
4. Head First Design Patterns (Эрик Фримен, Элизабет Робсон)
5. Документация Python: https://docs.python.org/3/
6. PEP 8 -- Style Guide for Python Code: https://pep8.org/

---

**Дата завершения работы:** 2025-11-24


