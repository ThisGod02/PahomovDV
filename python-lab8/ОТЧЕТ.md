# **Отчёт по лабораторной работе №8**

**Тема:** Тестирование программного обеспечения

## Сведения о студенте

**Дата:** 2025-12-22

**Семестр:** 2 курс 1 семестр

**Группа:** ПИН-Б-О-24-2

**Дисциплина:** Технологии программирования

**Студент:** Пахомов Давид Вадимович

---

## Оглавление

1. [Введение](#введение)
2. [Цель работы](#цель-работы)
3. [Структура проекта](#структура-проекта)
4. [Часть 1: Тестирование Employee](#часть-1-тестирование-employee)
5. [Часть 2: Тестирование наследования](#часть-2-тестирование-наследования)
6. [Часть 3: Тестирование полиморфизма и магических методов](#часть-3-тестирование-полиморфизма-и-магических-методов)
7. [Часть 4: Тестирование композиции и агрегации](#часть-4-тестирование-композиции-и-агрегации)
8. [Часть 5: Тестирование паттернов проектирования](#часть-5-тестирование-паттернов-проектирования)
9. [Результаты выполнения тестов](#результаты-выполнения-тестов)
10. [Выводы](#выводы)
11. [Заключение](#заключение)
12. [Приложения](#приложения)

---

## Введение

Тестирование программного обеспечения является критически важной частью процесса разработки. Модульное тестирование (unit testing) позволяет проверить корректность работы отдельных компонентов системы в изоляции от остальных частей. Использование фреймворка `pytest` и техник изоляции зависимостей с помощью моков и стабов значительно упрощает процесс написания и поддержки тестов.

Данная работа направлена на освоение основ модульного тестирования для системы учета сотрудников, реализованной на основе принципов ООП и паттернов проектирования. Система включает иерархию классов сотрудников, отделы, проекты, компанию и различные паттерны проектирования.

---

## Цель работы

Освоить основы модульного тестирования, научиться писать unit-тесты для классов и методов, использовать фреймворк `pytest`, применять техники изоляции зависимостей с помощью моков и стабов.

---

## Структура проекта

```
python-lab8/
├── src/                    # Исходный код
│   ├── core/              # Основные классы
│   │   ├── abstract_employee.py
│   │   ├── employee.py
│   │   ├── department.py
│   │   ├── company.py
│   │   └── project.py
│   ├── employees/         # Классы сотрудников
│   │   ├── manager.py
│   │   ├── developer.py
│   │   └── salesperson.py
│   ├── factories/         # Фабрики
│   │   └── employee_factory.py
│   ├── patterns/          # Паттерны проектирования
│   │   ├── singleton.py
│   │   ├── builder.py
│   │   ├── adapter.py
│   │   ├── decorator.py
│   │   ├── observer.py
│   │   ├── strategy.py
│   │   ├── command.py
│   │   ├── repository.py
│   │   └── specification.py
│   ├── database/         # База данных
│   │   └── connection.py
│   └── utils/            # Утилиты
│       └── exceptions.py
├── tests/                 # Тесты
│   ├── test_employee.py
│   ├── test_employees_hierarchy.py
│   ├── test_department.py
│   ├── test_project_company.py
│   └── test_patterns.py
├── requirements.txt
├── pytest.ini
└── ОТЧЕТ.md
```

---

## Часть 1: Тестирование Employee

**Цель:** Написать модульные тесты для класса `Employee`, проверяющие корректность инкапсуляции, валидации данных и работы методов.

### Реализованные тесты

1. **test_employee_creation_valid_data** - Проверка создания Employee с валидными данными
2. **test_employee_invalid_id_raises_error** - Валидация отрицательного ID
3. **test_employee_invalid_base_salary_raises_error** - Валидация отрицательной зарплаты
4. **test_employee_empty_name_raises_error** - Валидация пустого имени
5. **test_employee_calculate_salary** - Проверка расчета зарплаты
6. **test_employee_str_representation** - Проверка строкового представления
7. **test_employee_id_setter_validation** - Валидация сеттера ID
8. **test_employee_name_setter_validation** - Валидация сеттера имени
9. **test_employee_base_salary_setter_validation** - Валидация сеттера зарплаты
10. **test_employee_department_setter_validation** - Валидация сеттера отдела
11. **test_employee_get_info** - Проверка метода get_info

### Пример теста

```python
def test_employee_creation_valid_data(self):
    """Тест создания Employee с валидными данными."""
    # Arrange
    emp = Employee(1, "Alice", "IT", 5000)
    
    # Assert
    assert emp.id == 1
    assert emp.name == "Alice"
    assert emp.department == "IT"
    assert emp.base_salary == 5000
```

### Результаты

Все тесты для класса Employee успешно проходят. Проверена корректность:
- Инкапсуляции данных через приватные атрибуты
- Валидации входных данных
- Работы сеттеров и геттеров
- Методов calculate_salary() и get_info()

---

## Часть 2: Тестирование наследования

**Цель:** Написать модульные тесты для иерархии классов сотрудников, проверяющие корректность наследования, реализацию абстрактных методов и полиморфное поведение.

### Реализованные тесты

1. **test_cannot_create_abstract_employee** - Невозможность создания AbstractEmployee
2. **test_manager_salary_calculation** - Расчет зарплаты менеджера с бонусом
3. **test_manager_get_info_includes_bonus** - Информация о бонусе в get_info
4. **test_manager_bonus_setter_validation** - Валидация сеттера бонуса
5. **test_developer_salary_by_level** - Параметризованный тест расчета зарплаты по уровням
6. **test_developer_add_skill** - Добавление навыка
7. **test_developer_get_info_includes_tech_stack** - Информация о стеке технологий
8. **test_developer_skills_iteration** - Итерация по навыкам
9. **test_salesperson_salary_calculation** - Расчет зарплаты с комиссией
10. **test_salesperson_update_sales** - Обновление объема продаж
11. **test_employee_factory_method** - Тест фабрики сотрудников
12. **test_polymorphic_behavior** - Полиморфное поведение

### Пример параметризованного теста

```python
@pytest.mark.parametrize("level,expected_salary", [
    ("junior", 5000),    # 5000 * 1.0
    ("middle", 7500),    # 5000 * 1.5
    ("senior", 10000)    # 5000 * 2.0
])
def test_developer_salary_by_level(self, level, expected_salary):
    """Параметризованный тест расчета зарплаты по уровням."""
    dev = Developer(1, "Alice", "DEV", 5000, ["Python"], level)
    assert dev.calculate_salary() == expected_salary
```

### Результаты

Все тесты для иерархии классов успешно проходят. Проверена корректность:
- Наследования и реализации абстрактных методов
- Полиморфного поведения при работе с коллекциями
- Работы фабрики сотрудников
- Параметризованного тестирования

---

## Часть 3: Тестирование полиморфизма и магических методов

**Цель:** Написать комплексные тесты для проверки полиморфного поведения, перегрузки операторов и магических методов.

### Реализованные тесты

1. **test_department_add_employee** - Добавление сотрудника в отдел
2. **test_department_remove_employee** - Удаление сотрудника
3. **test_department_calculate_total_salary_polymorphic** - Полиморфный расчет зарплат
4. **test_department_get_employee_count** - Статистика по типам сотрудников
5. **test_employee_equality** - Оператор равенства (__eq__)
6. **test_employee_salary_comparison** - Операторы сравнения (__lt__, __gt__)
7. **test_employee_addition** - Сложение зарплат (__add__)
8. **test_department_magic_methods** - Магические методы Department (__len__, __getitem__, __contains__)
9. **test_department_iteration** - Итерация по отделу
10. **test_developer_skills_iteration** - Итерация по навыкам разработчика
11. **test_employee_serialization** - Сериализация и десериализация
12. **test_employee_sorting** - Сортировка сотрудников
13. **test_department_integration** - Интеграционный тест

### Пример теста магических методов

```python
def test_employee_equality(self):
    """Тест оператора равенства (__eq__)."""
    emp1 = Employee(1, "John", "IT", 5000)
    emp2 = Employee(1, "Jane", "HR", 4000)  # Тот же ID
    emp3 = Employee(2, "Bob", "IT", 5000)    # Другой ID
    
    assert emp1 == emp2  # одинаковый ID
    assert emp1 != emp3   # разный ID
```

### Результаты

Все тесты для полиморфизма и магических методов успешно проходят. Проверена корректность:
- Полиморфного поведения при расчете зарплат
- Перегрузки операторов сравнения и арифметических операций
- Магических методов для удобной работы с объектами
- Сериализации и десериализации данных

---

## Часть 4: Тестирование композиции и агрегации

**Цель:** Написать тесты для проверки корректности работы композиции, агрегации, валидации данных и сложных бизнес-методов.

### Реализованные тесты

1. **test_project_team_management** - Управление командой проекта
2. **test_project_total_salary** - Расчет суммарной зарплаты команды
3. **test_project_invalid_status_raises_error** - Валидация статусов проектов
4. **test_company_department_management** - Управление отделами
5. **test_company_find_employee** - Поиск сотрудников
6. **test_company_cannot_delete_department_with_employees** - Ограничения при удалении
7. **test_company_duplicate_employee_id_raises_error** - Обработка дублирования ID
8. **test_company_serialization_roundtrip** - Сериализация компании
9. **test_company_department_statistics** - Статистика по отделам
10. **test_company_find_overloaded_employees** - Поиск перегруженных сотрудников
11. **test_complex_company_structure** - Комплексный интеграционный тест

### Пример теста композиции

```python
def test_project_team_management(self):
    """Тест управления командой проекта."""
    project = Project(1, "AI Platform", "Разработка AI системы", "2024-12-31", "planning")
    dev = Developer(1, "John", "DEV", 5000, ["Python"], "senior")
    
    project.add_team_member(dev)
    assert len(project.get_team()) == 1
    
    project.remove_team_member(1)
    assert len(project.get_team()) == 0
```

### Результаты

Все тесты для композиции и агрегации успешно проходят. Проверена корректность:
- Композиции (Project содержит команду)
- Агрегации (Company содержит отделы и проекты)
- Валидации данных и обработки исключений
- Бизнес-методов для анализа данных

---

## Часть 5: Тестирование паттернов проектирования

**Цель:** Написать тесты для проверки корректной работы различных паттернов проектирования.

### Реализованные тесты

#### Порождающие паттерны:
1. **test_singleton_pattern** - Паттерн Singleton
2. **test_employee_factory_method** - Паттерн Factory Method
3. **test_employee_builder_pattern** - Паттерн Builder

#### Структурные паттерны:
4. **test_salary_calculator_adapter** - Паттерн Adapter
5. **test_bonus_decorator** - Паттерн Decorator

#### Поведенческие паттерны:
6. **test_observer_pattern** - Паттерн Observer (с моками)
7. **test_bonus_strategy_pattern** - Паттерн Strategy
8. **test_command_pattern_with_undo** - Паттерн Command

#### Комбинированные паттерны:
9. **test_employee_repository** - Паттерн Repository
10. **test_specification_pattern** - Паттерн Specification
11. **test_complex_pattern_interaction** - Интеграционный тест взаимодействия паттернов

### Пример теста с моками

```python
def test_observer_pattern(self):
    """Тест паттерна Observer с моками."""
    employee = Employee(1, "John", "IT", 5000)
    observable_emp = ObservableEmployee(employee)
    observer = Mock(spec=Observer)
    
    observable_emp.attach(observer)
    observable_emp.set_base_salary(6000)
    
    observer.update.assert_called_once()
    call_args = observer.update.call_args
    assert call_args[0][0] == "salary_changed"
```

### Результаты

Все тесты для паттернов проектирования успешно проходят. Проверена корректность:
- Порождающих паттернов (Singleton, Factory, Builder)
- Структурных паттернов (Adapter, Decorator)
- Поведенческих паттернов (Observer, Strategy, Command)
- Комбинированных паттернов (Repository, Specification)
- Взаимодействия паттернов между собой

---

## Результаты выполнения тестов

### Статистика тестов

- **Всего тестов:** 60+
- **Покрытие:** Все основные классы и методы
- **Результат:** Все тесты проходят успешно

### Категории тестов

1. **Unit-тесты** - Тестирование отдельных классов и методов
2. **Интеграционные тесты** - Тестирование взаимодействия компонентов
3. **Параметризованные тесты** - Тестирование различных сценариев
4. **Тесты с моками** - Изоляция зависимостей

### Примеры выполнения

```
test_employee.py::TestEmployee::test_employee_creation_valid_data PASSED
test_employee.py::TestEmployee::test_employee_invalid_id_raises_error PASSED
test_employees_hierarchy.py::TestManager::test_manager_salary_calculation PASSED
test_department.py::TestDepartment::test_department_calculate_total_salary_polymorphic PASSED
test_patterns.py::TestSingletonPattern::test_singleton_pattern PASSED
```

---

## Выводы

### По каждой части

**Часть 1 (Employee):**
- Успешно проверена инкапсуляция данных
- Валидация входных данных работает корректно
- Все сеттеры и геттеры функционируют правильно

**Часть 2 (Наследование):**
- Абстрактные классы корректно реализованы
- Полиморфизм работает как ожидается
- Фабрика сотрудников создает объекты правильно

**Часть 3 (Полиморфизм и магические методы):**
- Магические методы реализованы корректно
- Полиморфное поведение при расчете зарплат работает
- Сериализация и десериализация функционируют правильно

**Часть 4 (Композиция и агрегация):**
- Композиция (Project-Employee) работает корректно
- Агрегация (Company-Department-Project) функционирует правильно
- Бизнес-методы возвращают корректные результаты

**Часть 5 (Паттерны):**
- Все паттерны реализованы и работают корректно
- Взаимодействие паттернов между собой функционирует
- Моки позволяют изолировать зависимости

### Общие выводы

1. **Покрытие тестами** - Система имеет хорошее покрытие тестами, что повышает надежность кода
2. **Качество кода** - Тесты помогают выявлять ошибки на ранних этапах разработки
3. **Документация** - Тесты служат живой документацией к коду
4. **Рефакторинг** - Наличие тестов позволяет безопасно рефакторить код

---

## Заключение

В ходе выполнения лабораторной работы №8 был реализован комплексный набор модульных тестов для системы учета сотрудников. Тесты покрывают все основные компоненты системы:

- Базовые классы и инкапсуляцию
- Наследование и полиморфизм
- Магические методы и операторы
- Композицию и агрегацию
- Паттерны проектирования

### Достигнутые результаты

1. **Создано 60+ тестов** для различных компонентов системы
2. **Использованы различные техники тестирования:**
   - Параметризованные тесты
   - Тесты с моками
   - Интеграционные тесты
3. **Проверена корректность работы:**
   - Валидации данных
   - Полиморфного поведения
   - Паттернов проектирования
   - Бизнес-логики

### Практическая значимость

Результаты работы демонстрируют:
- Важность модульного тестирования для обеспечения качества кода
- Эффективность использования pytest для написания тестов
- Преимущества использования моков для изоляции зависимостей
- Значение тестов как документации к коду

Тестирование является неотъемлемой частью процесса разработки программного обеспечения и позволяет создавать более надежные и поддерживаемые системы.

---

## Приложения

### Приложение A: Структура проекта

Полная структура проекта представлена в разделе [Структура проекта](#структура-проекта).

### Приложение B: Примеры кода

Все примеры кода находятся в соответствующих файлах:
- `tests/test_employee.py` - Тесты для Employee
- `tests/test_employees_hierarchy.py` - Тесты для иерархии классов
- `tests/test_department.py` - Тесты для полиморфизма
- `tests/test_project_company.py` - Тесты для композиции и агрегации
- `tests/test_patterns.py` - Тесты для паттернов

### Приложение C: Запуск тестов

Для запуска тестов используется команда:
```bash
pytest tests/ -v
```

Для запуска конкретного файла тестов:
```bash
pytest tests/test_employee.py -v
```

Для запуска с покрытием кода:
```bash
pytest tests/ --cov=src --cov-report=html
```

### Приложение D: Зависимости

Проект использует следующие зависимости:
- `pytest>=7.0.0` - Фреймворк для тестирования

Установка зависимостей:
```bash
pip install -r requirements.txt
```

---

## Список использованных источников

1. Кент Бек. «Разработка через тестирование: Практический пример».
2. Владимир Хориков. «Unit-тестирование».
3. Документация `pytest`: https://docs.pytest.org/en/stable/
4. Документация `unittest.mock`: https://docs.python.org/3/library/unittest.mock.html
5. "Design Patterns: Elements of Reusable Object-Oriented Software" - Gang of Four

---

**Дата завершения работы:** 2025-12-22


